__BRYTHON__.VFS_timestamp = 1580854404247
__BRYTHON__.use_VFS = true
var scripts = {"$timestamp": 1580854404247, "_ajax": [".js", "// ajax\nvar $module = (function($B){\n\neval($B.InjectBuiltins())\nvar $N = $B.builtins.None,\n    _b_ = $B.builtins\n\nvar add_to_res = function(res, key, val) {\n    if(isinstance(val, list)){\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res, key, val[j])\n        }\n    }else if (val instanceof File || val instanceof Blob){\n        res.append(key, val)\n    }else{res.append(key,str.$factory(val))}\n}\n\nfunction set_timeout(self, timeout){\n    if(timeout.seconds !== undefined){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                if(timeout.func){\n                    timeout.func()\n                }\n            },\n            timeout.seconds * 1000)\n    }\n}\n\nfunction _read(req){\n    var xhr = req.js,\n        res\n    if(xhr.responseType == \"json\"){\n        return $B.structuredclone2pyobj(xhr.response)\n    }\n    if(xhr.responseType == \"arraybuffer\"){\n        var abuf = new Uint8Array(xhr.response)\n        res = []\n        for(var i = 0, len = abuf.length; i < len; i++){\n            res.push(abuf[i])\n        }\n        return _b_.bytes.$factory(res)\n    }else{\n        return xhr.responseText\n    }\n}\n\nfunction handle_kwargs(self, kw, method){\n    var data,\n        headers,\n        cache,\n        mode,\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key]\n            if(typeof params == \"string\"){\n                data = params\n            }else{\n                if(params.__class__ !== _b_.dict){\n                    throw _b_.TypeError.$factory(\"wrong type for data, \" +\n                        \"expected dict or str, got \" + $B.class_name(params))\n                }\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key]))\n                }\n                data = items.join(\"&\")\n            }\n        }else if(key==\"headers\"){\n            headers = kw.$string_dict[key].$string_dict\n            for(var key in headers){\n                self.js.setRequestHeader(key, headers[key])\n            }\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key]\n            }else{\n                var f = kw.$string_dict[key]\n                ajax.bind(self, event, f)\n            }\n        }else if(key == \"mode\"){\n            if(kw.$string_dict[key] == \"binary\"){\n                self.js.responseType = \"arraybuffer\"\n                mode = \"binary\"\n            }else if(kw.$string_dict[key] == \"json\"){\n                self.js.responseType = \"json\"\n                mode = \"json\"\n            }\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key]\n        }\n    }\n    if((method == \"post\" || method == \"put\") && ! headers){\n        // For POST requests, set default header\n        self.js.setRequestHeader(\"Content-type\",\n                                 \"application/x-www-form-urlencoded\")\n    }\n    return {cache: cache, data:data, mode: mode, timeout: timeout}\n}\n\nvar ajax = {\n    __class__: _b_.type,\n    __mro__: [$B.JSObject, _b_.object],\n\n    __getattribute__ : function(self, attr){\n        // Special case for send : accept dict as parameters\n        if(attr == 'send'){\n            return function(params){\n                return ajax.send(self, params)\n            }\n        }else if(attr == 'xml'){ // alias\n            attr = 'responseXML'\n        }\n        // Otherwise default to JSObject method\n        return $B.JSObject.__getattribute__(self, attr)\n    },\n\n    __repr__ : function(self){return '<object Ajax>'},\n    __str__ : function(self){return '<object Ajax>'},\n\n    $infos: {\n        __module__: \"builtins\",\n        __name__: \"ajax\"\n    },\n\n    bind: function(self, evt, func){\n        // req.bind(evt,func) is the same as req.onevt = func\n        self.js['on' + evt] = function(){\n            try{\n                return func.apply(null, arguments)\n            }catch(err){\n                if(err.__class__ !== undefined){\n                    var msg = _b_.getattr(err, 'info') +\n                        '\\n' + err.__class__.$infos.__name__\n                    if(err.args){msg += ': ' + err.args[0]}\n                    try{getattr($B.stderr, \"write\")(msg)}\n                    catch(err){console.log(msg)}\n                }else{\n                    try{getattr($B.stderr, \"write\")(err)}\n                    catch(err1){console.log(err)}\n                }\n            }\n        }\n        return $N\n    },\n\n    send: function(self, params){\n        // params can be Python dictionary or string\n        var res = ''\n        if(!params){\n            self.js.send()\n            return $N\n        }else if(isinstance(params, str)){\n            res = params\n        }else if(isinstance(params, dict)){\n            if(self.headers['content-type'] == 'multipart/form-data'){\n                // The FormData object serializes the data in the 'multipart/form-data'\n                // content-type so we may as well override that header if it was set\n                // by the user.\n                res = new FormData()\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    add_to_res(res, str.$factory(items[i][0]), items[i][1])\n                }\n            }else{\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    var key = encodeURIComponent(str.$factory(items[i][0]));\n                    if(isinstance(items[i][1], list)){\n                        for (j = 0; j < items[i][1].length; j++) {\n                            res += key +'=' +\n                                encodeURIComponent(str.$factory(items[i][1][j])) + '&'\n                        }\n                    }else{\n                        res += key + '=' +\n                            encodeURIComponent(str.$factory(items[i][1])) + '&'\n                    }\n                }\n                res = res.substr(0, res.length - 1)\n            }\n        }else{\n            throw _b_.TypeError(\"send() argument must be string or dictionary, not '\" +\n                str.$factory(params.__class__) + \"'\")\n        }\n        self.js.send(res)\n        return $N\n    },\n\n    set_header: function(self,key,value){\n        self.js.setRequestHeader(key,value)\n        self.headers[key.toLowerCase()] = value.toLowerCase()\n    },\n\n    set_timeout: function(self, seconds, func){\n        self.js.$requestTimer = setTimeout(\n            function() {self.js.abort();func()},\n            seconds * 1000)\n    }\n}\n\najax.$factory = function(){\n\n    if(window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var xmlhttp = new XMLHttpRequest()\n    }else{// code for IE6, IE5\n        var xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\")\n    }\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        if(this.responseType == \"\" || this.responseType == \"text\"){\n            res.js.text = this.responseText\n        }\n        var timer = this.$requestTimer\n        if(state == 0 && this.onuninitialized){this.onuninitialized(res)}\n        else if(state == 1 && this.onloading){this.onloading(res)}\n        else if(state == 2 && this.onloaded){this.onloaded(res)}\n        else if(state == 3 && this.oninteractive){this.oninteractive(res)}\n        else if(state == 4 && this.oncomplete){\n            if(timer !== null){window.clearTimeout(timer)}\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax,\n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\n\nfunction _request_without_body(){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n    var self = ajax.$factory(),\n        items = handle_kwargs(self, kw, method),\n        qs = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    if(qs){\n        url += \"?\" + qs\n    }\n    if(! (items.cache === true)){\n        url += (qs ? \"&\" : \"?\") + (new Date()).getTime()\n    }\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.open(method.toUpperCase(), url, async)\n    self.js.send()\n}\n\nfunction _request_with_body(){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n\n    var self = ajax.$factory()\n    self.js.open(method.toUpperCase(), url, async)\n    var items = handle_kwargs(self, kw, method),\n        data = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.send(data)\n}\n\nfunction _delete(){\n    _request_without_body.call(null, \"delete\", ...arguments)\n}\n\nfunction get(){\n    _request_without_body.call(null, \"get\", ...arguments)\n}\n\nfunction head(){\n    _request_without_body.call(null, \"head\", ...arguments)\n}\n\nfunction options(){\n    _request_without_body.call(null, \"options\", ...arguments)\n}\n\nfunction post(){\n    _request_with_body.call(null, \"post\", ...arguments)\n}\n\nfunction put(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction file_upload(){\n    var $ = $B.args(\"file_upload\", 2, {url: null, \"file\": file},\n            [\"url\", \"file\"], arguments, {}, null, \"kw\"),\n        url = $.url,\n        file = $.file,\n        kw = $.kw\n\n    var formdata = new FormData()\n    formdata.append('filetosave', file, file.name)\n\n    var self = ajax.$factory()\n    self.js.open('POST', url, True)\n    self.js.send(formdata)\n\n    for(key in kw.$string_dict){\n        if(key.startsWith(\"on\")){\n            ajax.bind(self, key.substr(2), kw.$string_dict[key])\n        }\n    }\n}\n\n$B.set_func_names(ajax)\n\nreturn {\n    ajax: ajax,\n    Ajax: ajax,\n    delete: _delete,\n    file_upload: file_upload,\n    get: get,\n    head: head,\n    options: options,\n    post: post,\n    put: put\n}\n\n})(__BRYTHON__)\n"], "urllib.request": [".py", "from browser import ajax\nfrom . import error\n\nclass FileIO:\n\n def __init__(self,data):\n  self._data=data\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,*args):\n  pass\n  \n def read(self):\n  return self._data\n  \ndef urlopen(url,data=None ,timeout=None ):\n global result\n result=None\n \n def on_complete(req):\n  global result\n  if req.status ==200:\n   result=req\n   \n _ajax=ajax.ajax()\n _ajax.bind('complete',on_complete)\n if timeout is not None :\n  _ajax.set_timeout(timeout)\n  \n if data is None :\n  _ajax.open('GET',url,False )\n  _ajax.send()\n else :\n  _ajax.open('POST',url,False )\n  _ajax.send(data)\n  \n if result is not None :\n  if isinstance(result.text,str):\n   return FileIO(result.text)\n   \n  return FileIO(result.text())\n raise error.HTTPError('file not found')\n", ["browser", "browser.ajax", "urllib", "urllib.error"]], "urllib": [".py", "", [], 1], "urllib.error": [".py", "class HTTPError(Exception):pass\n", []], "browser": [".py", "", [], 1], "browser.ajax": [".py", "from _ajax import *\n", ["_ajax"]], "browser.html": [".py", "from _html import *\n", ["_html"]]}
__BRYTHON__.update_VFS(scripts)